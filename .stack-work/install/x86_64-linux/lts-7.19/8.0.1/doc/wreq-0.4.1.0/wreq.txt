-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An easy-to-use HTTP client library.
--   
--   A web client library that is designed for ease of use.
--   
--   Tutorial: <a>http://www.serpentine.com/wreq/tutorial.html</a>
--   
--   Features include:
--   
--   <ul>
--   <li>Simple but powerful <a>lens</a>-based API</li>
--   <li>A solid test suite, and built on reliable libraries like
--   http-client and lens</li>
--   <li>Session handling includes connection keep-alive and pooling, and
--   cookie persistence</li>
--   <li>Automatic response body decompression</li>
--   <li>Powerful multipart form and file upload handling</li>
--   <li>Support for JSON requests and responses, including navigation of
--   schema-less responses</li>
--   <li>Basic and OAuth2 bearer authentication</li>
--   <li>Early TLS support via the tls package</li>
--   </ul>
@package wreq
@version 0.4.1.0


-- | HTTP client types.
module Network.Wreq.Types

-- | Options for configuring a client.
data Options
Options :: Mgr -> Maybe Proxy -> Maybe Auth -> [Header] -> [(Text, Text)] -> Int -> Maybe CookieJar -> Maybe StatusChecker -> Options

-- | Either configuration for a <a>Manager</a>, or an actual
--   <a>Manager</a>.
--   
--   If only <a>ManagerSettings</a> are provided, then by default a new
--   <a>Manager</a> will be created for each request.
--   
--   <i>Note</i>: when issuing HTTP requests using <a>Options</a>-based
--   functions from the the <a>Network.Wreq.Session</a> module
--   (<a>getWith</a>, <a>putWith</a>, etc.), this field will be ignored.
--   
--   An example of using a specific manager:
--   
--   <pre>
--   import <a>Network.HTTP.Client</a> (<a>withManager</a>)
--   
--   <a>withManager</a> $ \mgr -&gt; do
--     let opts = <a>defaults</a> { <a>manager</a> = Right mgr }
--     <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   An example of changing settings (this will use a separate
--   <a>Manager</a> for every request, so make sense only if you're issuing
--   a tiny handful of requets):
--   
--   <pre>
--   import <a>Network.HTTP.Client</a> (<a>defaultManagerSettings</a>)
--   
--   let settings = <a>defaultManagerSettings</a> { managerConnCount = 5 }
--       opts = <a>defaults</a> { <a>manager</a> = Left settings }
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
[manager] :: Options -> Mgr

-- | Host name and port for a proxy to use, if any.
[proxy] :: Options -> Maybe Proxy

-- | Authentication information.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> { <a>auth</a> = <a>basicAuth</a> "user" "pass" }
--   <a>getWith</a> opts "https://httpbin.org/basic-auth/user/pass"
--    
--   </pre>
[auth] :: Options -> Maybe Auth

-- | Additional headers to send with each request.
--   
--   <pre>
--   let opts = <a>defaults</a> { <a>headers</a> = [("Accept", "*/*")] }
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
[headers] :: Options -> [Header]

-- | Key-value pairs to assemble into a query string to add to the end of a
--   URL.
--   
--   For example, given:
--   
--   <pre>
--   let opts = <a>defaults</a> { params = [("sort", "ascending"), ("key", "name")] }
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   This will generate a URL of the form:
--   
--   <pre>
--   http://httpbin.org/get?sort=ascending&amp;key=name
--   </pre>
[params] :: Options -> [(Text, Text)]

-- | The maximum number of HTTP redirects to follow before giving up and
--   throwing an exception.
--   
--   In this example, a <a>HttpException</a> will be thrown with a
--   <a>TooManyRedirects</a> constructor, because the maximum number of
--   redirects allowed will be exceeded:
--   
--   <pre>
--   let opts = <a>defaults</a> { <a>redirects</a> = 3 }
--   <a>getWith</a> opts "http://httpbin.org/redirect/5"
--    
--   </pre>
[redirects] :: Options -> Int

-- | Cookies to set when issuing requests.
--   
--   <i>Note</i>: when issuing HTTP requests using <a>Options</a>-based
--   functions from the the <a>Network.Wreq.Session</a> module
--   (<a>getWith</a>, <a>putWith</a>, etc.), this field will be used only
--   for the <i>first</i> HTTP request to be issued during a
--   <a>Session</a>. Any changes changes made for subsequent requests will
--   be ignored.
[cookies] :: Options -> Maybe CookieJar

-- | Function that checks the status code and potentially returns an
--   exception.
--   
--   This defaults to <a>Nothing</a>, which will just use the default of
--   <a>Request</a> which throws a <tt>StatusException</tt> if the status
--   is not 2XX.
[checkStatus] :: Options -> Maybe StatusChecker

-- | Supported authentication types.
--   
--   Do not use HTTP authentication unless you are using TLS encryption.
--   These authentication tokens can easily be captured and reused by an
--   attacker if transmitted in the clear.
data Auth

-- | Basic authentication. This consists of a plain username and password.
BasicAuth :: ByteString -> ByteString -> Auth

-- | An OAuth2 bearer token. This is treated by many services as the
--   equivalent of a username and password.
OAuth2Bearer :: ByteString -> Auth

-- | A not-quite-standard OAuth2 bearer token (that seems to be used only
--   by GitHub). This is treated by whoever accepts it as the equivalent of
--   a username and password.
OAuth2Token :: ByteString -> Auth

-- | Amazon Web Services request signing AWSAuthVersion key secret
AWSAuth :: AWSAuthVersion -> ByteString -> ByteString -> Auth

-- | OAuth1 request signing OAuth1 consumerToken consumerSecret token
--   secret
OAuth1 :: ByteString -> ByteString -> ByteString -> ByteString -> Auth
data AWSAuthVersion

-- | AWS request signing version 4
AWSv4 :: AWSAuthVersion

-- | A function that checks the result of a HTTP request and potentially
--   returns an exception.
type StatusChecker = Status -> ResponseHeaders -> CookieJar -> Maybe SomeException

-- | A product type for representing more complex payload types.
data Payload
[Raw] :: ContentType -> RequestBody -> Payload

-- | A type that can be converted into a POST request payload.
class Postable a

-- | Represent a value in the request body (and perhaps the headers) of a
--   POST request.
postPayload :: Postable a => a -> Request -> IO Request

-- | A type that can be converted into a PUT request payload.
class Putable a

-- | Represent a value in the request body (and perhaps the headers) of a
--   PUT request.
putPayload :: Putable a => a -> Request -> IO Request

-- | A key/value pair for an <tt>application/x-www-form-urlencoded</tt>
--   POST request body.
data FormParam
[:=] :: (FormValue v) => ByteString -> v -> FormParam

-- | A type that can be rendered as the value portion of a key/value pair
--   for use in an <tt>application/x-www-form-urlencoded</tt> POST body.
--   Intended for use with the <a>FormParam</a> type.
--   
--   The instances for <a>String</a>, strict <a>Text</a>, and lazy
--   <a>Text</a> are all encoded using UTF-8 before being URL-encoded.
--   
--   The instance for <a>Maybe</a> gives an empty string on <a>Nothing</a>,
--   and otherwise uses the contained type's instance.
class FormValue a

-- | Render the given value.
renderFormValue :: FormValue a => a -> ByteString

-- | A MIME content type, e.g. <tt>"application/octet-stream"</tt>.
type ContentType = ByteString

-- | An element of a <tt>Link</tt> header.
data Link
Link :: ByteString -> [(ByteString, ByteString)] -> Link
[linkURL] :: Link -> ByteString
[linkParams] :: Link -> [(ByteString, ByteString)]

-- | The error type used by <a>asJSON</a> and <a>asValue</a> if a failure
--   occurs when parsing a response body as JSON.
data JSONError
JSONError :: String -> JSONError

-- | A request that is ready to be submitted.
data Req

-- | Return the URL associated with the given <a>Req</a>.
--   
--   This includes the port number if not standard, and the query string if
--   one exists.
reqURL :: Req -> ByteString

-- | A function that runs a request and returns the associated response.
type Run body = Req -> IO (Response body)
instance Network.Wreq.Internal.Types.Postable Network.HTTP.Client.MultipartFormData.Part
instance Network.Wreq.Internal.Types.Postable [Network.HTTP.Client.MultipartFormData.Part]
instance Network.Wreq.Internal.Types.Postable [(Data.ByteString.Internal.ByteString, Data.ByteString.Internal.ByteString)]
instance Network.Wreq.Internal.Types.Postable (Data.ByteString.Internal.ByteString, Data.ByteString.Internal.ByteString)
instance Network.Wreq.Internal.Types.Postable [Network.Wreq.Internal.Types.FormParam]
instance Network.Wreq.Internal.Types.Postable Network.Wreq.Internal.Types.FormParam
instance Network.Wreq.Internal.Types.Postable Network.Wreq.Internal.Types.Payload
instance Network.Wreq.Internal.Types.Postable Data.ByteString.Internal.ByteString
instance Network.Wreq.Internal.Types.Postable Data.ByteString.Lazy.Internal.ByteString
instance Network.Wreq.Internal.Types.Postable Data.Aeson.Types.Internal.Value
instance Network.Wreq.Internal.Types.Putable Network.Wreq.Internal.Types.Payload
instance Network.Wreq.Internal.Types.Putable Data.ByteString.Internal.ByteString
instance Network.Wreq.Internal.Types.Putable Data.ByteString.Lazy.Internal.ByteString
instance Network.Wreq.Internal.Types.Putable Data.Aeson.Types.Internal.Value
instance Network.Wreq.Internal.Types.FormValue Data.Text.Internal.Text
instance Network.Wreq.Internal.Types.FormValue Data.Text.Internal.Lazy.Text
instance Network.Wreq.Internal.Types.FormValue Data.Text.Internal.Builder.Builder
instance Network.Wreq.Internal.Types.FormValue GHC.Base.String
instance Network.Wreq.Internal.Types.FormValue Data.ByteString.Internal.ByteString
instance Network.Wreq.Internal.Types.FormValue Data.ByteString.Lazy.Internal.ByteString
instance Network.Wreq.Internal.Types.FormValue GHC.Types.Int
instance Network.Wreq.Internal.Types.FormValue GHC.Int.Int8
instance Network.Wreq.Internal.Types.FormValue GHC.Int.Int16
instance Network.Wreq.Internal.Types.FormValue GHC.Int.Int32
instance Network.Wreq.Internal.Types.FormValue GHC.Int.Int64
instance Network.Wreq.Internal.Types.FormValue GHC.Integer.Type.Integer
instance Network.Wreq.Internal.Types.FormValue GHC.Types.Word
instance Network.Wreq.Internal.Types.FormValue GHC.Word.Word8
instance Network.Wreq.Internal.Types.FormValue GHC.Word.Word16
instance Network.Wreq.Internal.Types.FormValue GHC.Word.Word32
instance Network.Wreq.Internal.Types.FormValue GHC.Word.Word64
instance Network.Wreq.Internal.Types.FormValue GHC.Types.Float
instance Network.Wreq.Internal.Types.FormValue GHC.Types.Double
instance Network.Wreq.Internal.Types.FormValue ()
instance Network.Wreq.Internal.Types.FormValue a => Network.Wreq.Internal.Types.FormValue (GHC.Base.Maybe a)


-- | HTTP client lens machinery.
--   
--   When reading the examples in this module, you should assume the
--   following environment:
--   
--   <pre>
--   -- Make it easy to write literal <a>ByteString</a> and <a>Text</a> values.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   -- Our handy module.
--   import <a>Network.Wreq</a>
--   
--   -- Operators such as (<tt>&amp;</tt>) and (<tt>.~</tt>).
--   import <a>Control.Lens</a>
--   
--   -- Conversion of Haskell values to JSON.
--   import <a>Data.Aeson</a> (<a>toJSON</a>)
--   
--   -- Easy traversal of JSON data.
--   import <a>Data.Aeson.Lens</a> (<a>key</a>, <a>nth</a>)
--   </pre>
module Network.Wreq.Lens

-- | Options for configuring a client.
data Options

-- | A lens onto configuration of the connection manager provided by the
--   http-client package.
--   
--   In this example, we enable the use of OpenSSL for (hopefully) secure
--   connections:
--   
--   <pre>
--   import <a>OpenSSL.Session</a> (<a>context</a>)
--   import <a>Network.HTTP.Client.OpenSSL</a>
--   
--   let opts = <a>defaults</a> <a>&amp;</a> <a>manager</a> <a>.~</a> Left (<a>opensslManagerSettings</a> <a>context</a>)
--   <a>withOpenSSL</a> $
--     <a>getWith</a> opts "https://httpbin.org/get"
--    
--   </pre>
--   
--   In this example, we also set the response timeout to 10000
--   microseconds:
--   
--   <pre>
--   import <a>OpenSSL.Session</a> (<a>context</a>)
--   import <a>Network.HTTP.Client.OpenSSL</a>
--   import <a>Network.HTTP.Client</a> (<a>defaultManagerSettings</a>, <a>managerResponseTimeout</a>)
--   
--   let opts = <a>defaults</a> <a>&amp;</a> <a>manager</a> <a>.~</a> Left (<a>opensslManagerSettings</a> <a>context</a>)
--                       <a>&amp;</a> <a>manager</a> <a>.~</a> Left (<a>defaultManagerSettings</a> { <a>managerResponseTimeout</a> = Just 10000 } )
--   
--   <a>withOpenSSL</a> $
--     <a>getWith</a> opts "https://httpbin.org/get"
--    
--   </pre>
manager :: Lens' Options (Either ManagerSettings Manager)

-- | A lens onto proxy configuration.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>proxy</a> <a>?~</a> <a>httpProxy</a> "localhost" 8000
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   Note here the use of the <a>?~</a> setter to turn a <a>Proxy</a> into
--   a <a>Maybe</a> <a>Proxy</a>, to make the type of the RHS compatible
--   with the <a>proxy</a> lens.
proxy :: Lens' Options (Maybe Proxy)

-- | A lens onto request authentication.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>auth</a> <a>?~</a> <a>basicAuth</a> "user" "pass"
--   <a>getWith</a> opts "https://httpbin.org/basic-auth/user/pass"
--    
--   </pre>
auth :: Lens' Options (Maybe Auth)

-- | A lens onto all headers with the given name (there can legitimately be
--   zero or more).
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>header</a> "Accept" <a>.~</a> ["*/*"]
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
header :: HeaderName -> Lens' Options [ByteString]

-- | A lens onto all query parameters with the given name (there can
--   legitimately be zero or more).
--   
--   In this example, we construct the query URL
--   "<tt>http://httpbin.org/get?foo=bar&amp;foo=quux</tt>".
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>param</a> "foo" <a>.~</a> ["bar", "quux"]
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
param :: Text -> Lens' Options [Text]

-- | A lens onto the maximum number of redirects that will be followed
--   before an exception is thrown.
--   
--   In this example, a <a>HttpException</a> will be thrown with a
--   <a>TooManyRedirects</a> constructor, because the maximum number of
--   redirects allowed will be exceeded.
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>redirects</a> <a>.~</a> 3
--   <a>getWith</a> opts "http://httpbin.org/redirect/5"
--    
--   </pre>
redirects :: Lens' Options Int

-- | A lens onto all headers (there can legitimately be zero or more).
--   
--   In this example, we print all the headers sent by default with every
--   request.
--   
--   <pre>
--   print (<a>defaults</a> <a>^.</a> <a>headers</a>)
--    
--   </pre>
headers :: Lens' Options [Header]

-- | A lens onto all query parameters.
params :: Lens' Options [(Text, Text)]

-- | A traversal onto the cookie with the given name, if one exists.
--   
--   N.B. This is an "illegal" <a>Traversal'</a>: we can change the
--   <a>cookieName</a> of the associated <a>Cookie</a> so that it differs
--   from the name provided to this function.
cookie :: ByteString -> Traversal' Options Cookie

-- | A lens onto all cookies.
cookies :: Lens' Options (Maybe CookieJar)

-- | A function that checks the result of a HTTP request and potentially
--   returns an exception.
type StatusChecker = Status -> ResponseHeaders -> CookieJar -> Maybe SomeException

-- | A lens to get the optional status check function
checkStatus :: Lens' Options (Maybe StatusChecker)

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy :: *

-- | A lens onto the hostname portion of a proxy configuration.
proxyHost :: Lens' Proxy ByteString

-- | A lens onto the TCP port number of a proxy configuration.
proxyPort :: Lens' Proxy Int
data Cookie :: *

-- | A lens onto the name of a cookie.
cookieName :: Lens' Cookie ByteString

-- | A lens onto the value of a cookie.
cookieValue :: Lens' Cookie ByteString

-- | A lens onto the expiry time of a cookie.
cookieExpiryTime :: Lens' Cookie UTCTime

-- | A lens onto the domain of a cookie.
cookieDomain :: Lens' Cookie ByteString

-- | A lens onto the path of a cookie.
cookiePath :: Lens' Cookie ByteString

-- | A lens onto the creation time of a cookie.
cookieCreationTime :: Lens' Cookie UTCTime

-- | A lens onto the last access time of a cookie.
cookieLastAccessTime :: Lens' Cookie UTCTime

-- | A lens onto whether a cookie is persistent across sessions (also known
--   as a "tracking cookie").
cookiePersistent :: Lens' Cookie Bool

-- | A lens onto whether a cookie is host-only.
cookieHostOnly :: Lens' Cookie Bool

-- | A lens onto whether a cookie is secure-only, such that it will only be
--   used over TLS.
cookieSecureOnly :: Lens' Cookie Bool

-- | A lens onto whether a cookie is "HTTP-only".
--   
--   Such cookies should be used only by browsers when transmitting HTTP
--   requests. They must be unavailable in non-browser environments, such
--   as when executing JavaScript scripts.
cookieHttpOnly :: Lens' Cookie Bool

-- | A simple representation of the HTTP response.
--   
--   Since 0.1.0
data Response body :: * -> *

-- | A lens onto the body of a response.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^.</a> <a>responseBody</a>)
--    
--   </pre>
responseBody :: Lens (Response body0) (Response body1) body0 body1

-- | A lens onto all matching named headers in an HTTP response.
--   
--   To access exactly one header (the result will be the empty string if
--   there is no match), use the (<a>^.</a>) operator.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^.</a> <a>responseHeader</a> "Content-Type")
--    
--   </pre>
--   
--   To access at most one header (the result will be <a>Nothing</a> if
--   there is no match), use the (<a>^?</a>) operator.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^?</a> <a>responseHeader</a> "Content-Transfer-Encoding")
--    
--   </pre>
--   
--   To access all (zero or more) matching headers, use the (<a>^..</a>)
--   operator.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^..</a> <a>responseHeader</a> "Set-Cookie")
--    
--   </pre>
responseHeader :: HeaderName -> Traversal' (Response body) ByteString

-- | A fold over <tt>Link</tt> headers, matching on both parameter name and
--   value.
--   
--   For example, here is a <tt>Link</tt> header returned by the GitHub
--   search API.
--   
--   <pre>
--   Link:
--     &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=2&gt;; rel="next",
--     &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel="last"
--   </pre>
--   
--   And here is an example of how we can retrieve the URL for the
--   <tt>next</tt> link programatically.
--   
--   <pre>
--   r &lt;- <a>get</a> "https://api.github.com/search/code?q=addClass+user:mozilla"
--   print (r <a>^?</a> <a>responseLink</a> "rel" "next" . <a>linkURL</a>)
--    
--   </pre>
responseLink :: ByteString -> ByteString -> Fold (Response body) Link

-- | A fold over any cookies that match the given name.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://www.nytimes.com/"
--   print (r <a>^?</a> responseCookie "RMID")
--    
--   </pre>
responseCookie :: ByteString -> Fold (Response body) Cookie

-- | A lens onto all headers in an HTTP response.
responseHeaders :: Lens' (Response body) ResponseHeaders

-- | A lens onto all cookies set in the response.
responseCookieJar :: Lens' (Response body) CookieJar

-- | A lens onto the status of an HTTP response.
responseStatus :: Lens' (Response body) Status

-- | A lens onto the version of an HTTP response.
responseVersion :: Lens' (Response body) HttpVersion

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the status code constants
--   (like <a>ok200</a>). There might be additional record members in the
--   future.
--   
--   Note that the Show instance is only for debugging.
data Status :: *

-- | A lens onto the numeric identifier of an HTTP status.
statusCode :: Lens' Status Int

-- | A lens onto the textual description of an HTTP status.
statusMessage :: Lens' Status ByteString

-- | An element of a <tt>Link</tt> header.
data Link

-- | A lens onto the URL portion of a <tt>Link</tt> element.
linkURL :: Lens' Link ByteString

-- | A lens onto the parameters of a <tt>Link</tt> element.
linkParams :: Lens' Link [(ByteString, ByteString)]

-- | A single part of a multipart message.
data Part :: *

-- | A lens onto the name of the <tt><a>input</a></tt> element associated
--   with part of a multipart form upload.
partName :: Lens' Part Text

-- | A lens onto the filename associated with part of a multipart form
--   upload.
partFileName :: Lens' Part (Maybe String)

-- | A lens onto the content-type associated with part of a multipart form
--   upload.
partContentType :: Traversal' Part (Maybe MimeType)

-- | A lens onto the code that fetches the data associated with part of a
--   multipart form upload.
partGetBody :: Lens' Part (IO RequestBody)

-- | Turn an attoparsec <a>Parser</a> into a <a>Fold</a>.
--   
--   Both headers and bodies can contain complicated data that we may need
--   to parse.
--   
--   Example: when responding to an OPTIONS request, a server may return
--   the list of verbs it supports in any order, up to and including
--   changing the order on every request (which httpbin.org /actually
--   does/!). To deal with this possibility, we parse the list, then sort
--   it.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Attoparsec.ByteString.Char8 as A
--   
--   &gt;&gt;&gt; import Data.List (sort)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; let comma = skipSpace &gt;&gt; "," &gt;&gt; skipSpace
--   
--   &gt;&gt;&gt; let verbs = A.takeWhile isAlpha_ascii `sepBy` comma
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; r &lt;- options "http://httpbin.org/get"
--   
--   &gt;&gt;&gt; r ^. responseHeader "Allow" . atto verbs . to sort
--   ["GET","HEAD","OPTIONS"]
--   </pre>
atto :: Parser a -> Fold ByteString a

-- | The same as <a>atto</a>, but ensures that the parser consumes the
--   entire input.
--   
--   Equivalent to:
--   
--   <pre>
--   <a>atto_</a> myParser = <a>atto</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
atto_ :: Parser a -> Fold ByteString a

module Network.Wreq.Cache.Store
data Store k v
empty :: Ord k => Int -> Store k v
insert :: (Ord k, Hashable k) => k -> v -> Store k v -> Store k v
delete :: (Ord k, Hashable k) => k -> Store k v -> Store k v
lookup :: (Ord k, Hashable k) => k -> Store k v -> Maybe (v, Store k v)
fromList :: (Ord k, Hashable k) => Int -> [(k, v)] -> Store k v
toList :: (Ord k, Hashable k) => Store k v -> [(k, v)]
instance (GHC.Show.Show k, GHC.Show.Show v, GHC.Classes.Ord k, Data.Hashable.Class.Hashable k) => GHC.Show.Show (Network.Wreq.Cache.Store.Store k v)

module Network.Wreq.Cache
shouldCache :: UTCTime -> Req -> Response body -> Maybe (CacheEntry body)
validateEntry :: UTCTime -> CacheEntry body -> Maybe (Response body)
cacheStore :: Int -> IO (Run body -> Run body)
instance GHC.Generics.Generic (Network.Wreq.Cache.CacheResponse age)
instance GHC.Base.Functor Network.Wreq.Cache.CacheResponse
instance GHC.Show.Show age => GHC.Show.Show (Network.Wreq.Cache.CacheResponse age)
instance GHC.Classes.Eq age => GHC.Classes.Eq (Network.Wreq.Cache.CacheResponse age)
instance Data.Hashable.Class.Hashable age => Data.Hashable.Class.Hashable (Network.Wreq.Cache.CacheResponse age)


-- | A library for client-side HTTP requests, focused on ease of use.
--   
--   When reading the examples in this module, you should assume the
--   following environment:
--   
--   <pre>
--   -- Make it easy to write literal <a>ByteString</a> and <a>Text</a> values.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   -- Our handy module.
--   import <a>Network.Wreq</a>
--   
--   -- Operators such as (<a>&amp;</a>) and (<a>.~</a>).
--   import <a>Control.Lens</a>
--   
--   -- Conversion of Haskell values to JSON.
--   import <a>Data.Aeson</a> (<a>toJSON</a>)
--   
--   -- Easy traversal of JSON data.
--   import <a>Data.Aeson.Lens</a> (<a>key</a>, <a>nth</a>)
--   </pre>
--   
--   There exist some less frequently used lenses that are not exported
--   from this module; these can be found in <a>Network.Wreq.Lens</a>.
module Network.Wreq

-- | Issue a GET request.
--   
--   Example:
--   
--   <pre>
--   <a>get</a> "http://httpbin.org/get"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; r &lt;- get "http://httpbin.org/get"
--   
--   &gt;&gt;&gt; r ^. responseStatus . statusCode
--   200
--   </pre>
get :: String -> IO (Response ByteString)

-- | Issue a GET request, using the supplied <a>Options</a>.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>param</a> "foo" <a>.~</a> ["bar"]
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let opts = defaults &amp; param "foo" .~ ["bar"]
--   
--   &gt;&gt;&gt; r &lt;- getWith opts "http://httpbin.org/get"
--   
--   &gt;&gt;&gt; r ^? responseBody . key "url"
--   Just (String "http://httpbin.org/get?foo=bar")
--   </pre>
getWith :: Options -> String -> IO (Response ByteString)

-- | Issue a POST request.
--   
--   Example:
--   
--   <pre>
--   <a>post</a> "http://httpbin.org/post" (<a>toJSON</a> [1,2,3])
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; r &lt;- post "http://httpbin.org/post" (toJSON [1,2,3])
--   
--   &gt;&gt;&gt; r ^? responseBody . key "json" . nth 2
--   Just (Number 3.0)
--   </pre>
post :: Postable a => String -> a -> IO (Response ByteString)

-- | Issue a POST request, using the supplied <a>Options</a>.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>param</a> "foo" <a>.~</a> ["bar"]
--   <a>postWith</a> opts "http://httpbin.org/post" (<a>toJSON</a> [1,2,3])
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let opts = defaults &amp; param "foo" .~ ["bar"]
--   
--   &gt;&gt;&gt; r &lt;- postWith opts "http://httpbin.org/post" (toJSON [1,2,3])
--   
--   &gt;&gt;&gt; r ^? responseBody . key "url"
--   Just (String "http://httpbin.org/post?foo=bar")
--   </pre>
postWith :: Postable a => Options -> String -> a -> IO (Response ByteString)

-- | Issue a HEAD request.
--   
--   Example:
--   
--   <pre>
--   <a>head_</a> "http://httpbin.org/get"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; r &lt;- head_ "http://httpbin.org/get"
--   
--   &gt;&gt;&gt; r ^? responseHeader "Content-Type"
--   Just "application/json"
--   </pre>
head_ :: String -> IO (Response ())

-- | Issue a HEAD request, using the supplied <a>Options</a>.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>param</a> "foo" <a>.~</a> ["bar"]
--   <a>headWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let opts = defaults &amp; param "foo" .~ ["bar"]
--   
--   &gt;&gt;&gt; r &lt;- headWith opts "http://httpbin.org/get"
--   
--   &gt;&gt;&gt; r ^? responseHeader "Connection"
--   Just "keep-alive"
--   </pre>
headWith :: Options -> String -> IO (Response ())

-- | Issue an OPTIONS request.
--   
--   Example:
--   
--   <pre>
--   <a>options</a> "http://httpbin.org/get"
--    
--   </pre>
--   
--   See <a>atto</a> for a more complex worked example.
options :: String -> IO (Response ())

-- | Issue an OPTIONS request, using the supplied <a>Options</a>.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>param</a> "foo" <a>.~</a> ["bar"]
--   <a>optionsWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
optionsWith :: Options -> String -> IO (Response ())

-- | Issue a PUT request.
put :: Putable a => String -> a -> IO (Response ByteString)

-- | Issue a PUT request, using the supplied <a>Options</a>.
putWith :: Putable a => Options -> String -> a -> IO (Response ByteString)

-- | Issue a DELETE request.
--   
--   Example:
--   
--   <pre>
--   <a>delete</a> "http://httpbin.org/delete"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; r &lt;- delete "http://httpbin.org/delete"
--   
--   &gt;&gt;&gt; r ^. responseStatus . statusCode
--   200
--   </pre>
delete :: String -> IO (Response ByteString)

-- | Issue a DELETE request, using the supplied <a>Options</a>.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>redirects</a> <a>.~</a> 0
--   <a>deleteWith</a> opts "http://httpbin.org/delete"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let opts = defaults &amp; redirects .~ 0
--   
--   &gt;&gt;&gt; r &lt;- deleteWith opts "http://httpbin.org/delete"
--   
--   &gt;&gt;&gt; r ^. responseStatus . statusCode
--   200
--   </pre>
deleteWith :: Options -> String -> IO (Response ByteString)

-- | Issue a custom-method request
--   
--   Example: <tt> <a>customMethod</a> "PATCH" "http://httpbin.org/patch"
--   </tt>
--   
--   <pre>
--   &gt;&gt;&gt; r &lt;- customMethod "PATCH" "http://httpbin.org/patch"
--   
--   &gt;&gt;&gt; r ^. responseStatus . statusCode
--   200
--   </pre>
customMethod :: String -> String -> IO (Response ByteString)

-- | Issue a custom request method request, using the supplied
--   <a>Options</a>.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>redirects</a> <a>.~</a> 0
--   <a>customMethodWith</a> "PATCH" opts "http://httpbin.org/patch"
--    
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let opts = defaults &amp; redirects .~ 0
--   
--   &gt;&gt;&gt; r &lt;- customMethodWith "PATCH" opts "http://httpbin.org/patch"
--   
--   &gt;&gt;&gt; r ^. responseStatus . statusCode
--   200
--   </pre>
customMethodWith :: String -> Options -> String -> IO (Response ByteString)

-- | Issue a custom-method request with a payload
customPayloadMethod :: Postable a => String -> String -> a -> IO (Response ByteString)

-- | Issue a custom-method request with a payload, using the supplied
--   <a>Options</a>.
customPayloadMethodWith :: Postable a => String -> Options -> String -> a -> IO (Response ByteString)
foldGet :: (a -> ByteString -> IO a) -> a -> String -> IO a
foldGetWith :: Options -> (a -> ByteString -> IO a) -> a -> String -> IO a

-- | Options for configuring a client.
data Options
defaults :: Options

-- | A lens onto configuration of the connection manager provided by the
--   http-client package.
--   
--   In this example, we enable the use of OpenSSL for (hopefully) secure
--   connections:
--   
--   <pre>
--   import <a>OpenSSL.Session</a> (<a>context</a>)
--   import <a>Network.HTTP.Client.OpenSSL</a>
--   
--   let opts = <a>defaults</a> <a>&amp;</a> <a>manager</a> <a>.~</a> Left (<a>opensslManagerSettings</a> <a>context</a>)
--   <a>withOpenSSL</a> $
--     <a>getWith</a> opts "https://httpbin.org/get"
--    
--   </pre>
--   
--   In this example, we also set the response timeout to 10000
--   microseconds:
--   
--   <pre>
--   import <a>OpenSSL.Session</a> (<a>context</a>)
--   import <a>Network.HTTP.Client.OpenSSL</a>
--   import <a>Network.HTTP.Client</a> (<a>defaultManagerSettings</a>, <a>managerResponseTimeout</a>)
--   
--   let opts = <a>defaults</a> <a>&amp;</a> <a>manager</a> <a>.~</a> Left (<a>opensslManagerSettings</a> <a>context</a>)
--                       <a>&amp;</a> <a>manager</a> <a>.~</a> Left (<a>defaultManagerSettings</a> { <a>managerResponseTimeout</a> = Just 10000 } )
--   
--   <a>withOpenSSL</a> $
--     <a>getWith</a> opts "https://httpbin.org/get"
--    
--   </pre>
manager :: Lens' Options (Either ManagerSettings Manager)

-- | A lens onto all headers with the given name (there can legitimately be
--   zero or more).
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>header</a> "Accept" <a>.~</a> ["*/*"]
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
header :: HeaderName -> Lens' Options [ByteString]

-- | A lens onto all query parameters with the given name (there can
--   legitimately be zero or more).
--   
--   In this example, we construct the query URL
--   "<tt>http://httpbin.org/get?foo=bar&amp;foo=quux</tt>".
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>param</a> "foo" <a>.~</a> ["bar", "quux"]
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
param :: Text -> Lens' Options [Text]

-- | A lens onto the maximum number of redirects that will be followed
--   before an exception is thrown.
--   
--   In this example, a <a>HttpException</a> will be thrown with a
--   <a>TooManyRedirects</a> constructor, because the maximum number of
--   redirects allowed will be exceeded.
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>redirects</a> <a>.~</a> 3
--   <a>getWith</a> opts "http://httpbin.org/redirect/5"
--    
--   </pre>
redirects :: Lens' Options Int

-- | A lens onto all headers (there can legitimately be zero or more).
--   
--   In this example, we print all the headers sent by default with every
--   request.
--   
--   <pre>
--   print (<a>defaults</a> <a>^.</a> <a>headers</a>)
--    
--   </pre>
headers :: Lens' Options [Header]

-- | A lens onto all query parameters.
params :: Lens' Options [(Text, Text)]

-- | A traversal onto the cookie with the given name, if one exists.
--   
--   N.B. This is an "illegal" <a>Traversal'</a>: we can change the
--   <a>cookieName</a> of the associated <a>Cookie</a> so that it differs
--   from the name provided to this function.
cookie :: ByteString -> Traversal' Options Cookie

-- | A lens onto all cookies.
cookies :: Lens' Options (Maybe CookieJar)

-- | A lens to get the optional status check function
checkStatus :: Lens' Options (Maybe StatusChecker)

-- | Supported authentication types.
--   
--   Do not use HTTP authentication unless you are using TLS encryption.
--   These authentication tokens can easily be captured and reused by an
--   attacker if transmitted in the clear.
data Auth
data AWSAuthVersion

-- | AWS request signing version 4
AWSv4 :: AWSAuthVersion

-- | A lens onto request authentication.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>auth</a> <a>?~</a> <a>basicAuth</a> "user" "pass"
--   <a>getWith</a> opts "https://httpbin.org/basic-auth/user/pass"
--    
--   </pre>
auth :: Lens' Options (Maybe Auth)

-- | Basic authentication. This consists of a plain username and password.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>auth</a> <tt>?~</tt> <a>basicAuth</a> "user" "pass"
--   <a>getWith</a> opts "https://httpbin.org/basic-auth/user/pass"
--    
--   </pre>
--   
--   Note here the use of the <a>?~</a> setter to turn an <a>Auth</a> into
--   a <a>Maybe</a> <a>Auth</a>, to make the type of the RHS compatible
--   with the <a>auth</a> lens.
--   
--   <pre>
--   &gt;&gt;&gt; let opts = defaults &amp; auth ?~ basicAuth "user" "pass"
--   
--   &gt;&gt;&gt; r &lt;- getWith opts "https://httpbin.org/basic-auth/user/pass"
--   
--   &gt;&gt;&gt; r ^? responseBody . key "authenticated"
--   Just (Bool True)
--   </pre>
basicAuth :: ByteString -> ByteString -> Auth

-- | OAuth1 authentication. This consists of a consumer token, a consumer
--   secret, a token and a token secret
oauth1Auth :: ByteString -> ByteString -> ByteString -> ByteString -> Auth

-- | An OAuth2 bearer token. This is treated by many services as the
--   equivalent of a username and password.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>auth</a> <tt>?~</tt> <a>oauth2Bearer</a> "1234abcd"
--   <a>getWith</a> opts "https://public-api.wordpress.com/rest/v1/me/"
--    
--   </pre>
oauth2Bearer :: ByteString -> Auth

-- | A not-quite-standard OAuth2 bearer token (that seems to be used only
--   by GitHub). This will be treated by whatever services accept it as the
--   equivalent of a username and password.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>auth</a> <tt>?~</tt> <a>oauth2Token</a> "abcd1234"
--   <a>getWith</a> opts "https://api.github.com/user"
--    
--   </pre>
oauth2Token :: ByteString -> Auth

-- | AWS v4 request signature.
--   
--   Example (note the use of TLS):
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>auth</a> <tt>?~</tt> 'awsAuth AWSv4' "key" "secret"
--   <a>getWith</a> opts "https://dynamodb.us-west-2.amazonaws.com"
--    
--   </pre>
awsAuth :: AWSAuthVersion -> ByteString -> ByteString -> Auth

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy :: *
Proxy :: ByteString -> Int -> Proxy

-- | A lens onto proxy configuration.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>proxy</a> <a>?~</a> <a>httpProxy</a> "localhost" 8000
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   Note here the use of the <a>?~</a> setter to turn a <a>Proxy</a> into
--   a <a>Maybe</a> <a>Proxy</a>, to make the type of the RHS compatible
--   with the <a>proxy</a> lens.
proxy :: Lens' Options (Maybe Proxy)

-- | Proxy configuration.
--   
--   Example:
--   
--   <pre>
--   let opts = <a>defaults</a> <a>&amp;</a> <a>proxy</a> <tt>?~</tt> <a>httpProxy</a> "localhost" 8000
--   <a>getWith</a> opts "http://httpbin.org/get"
--    
--   </pre>
--   
--   Note here the use of the <a>?~</a> setter to turn a <a>Proxy</a> into
--   a <a>Maybe</a> <a>Proxy</a>, to make the type of the RHS compatible
--   with the <a>proxy</a> lens.
httpProxy :: ByteString -> Int -> Proxy
withManager :: (Options -> IO a) -> IO a

-- | A product type for representing more complex payload types.
data Payload
[Raw] :: ContentType -> RequestBody -> Payload

-- | A key/value pair for an <tt>application/x-www-form-urlencoded</tt>
--   POST request body.
data FormParam
[:=] :: (FormValue v) => ByteString -> v -> FormParam

-- | A type that can be rendered as the value portion of a key/value pair
--   for use in an <tt>application/x-www-form-urlencoded</tt> POST body.
--   Intended for use with the <a>FormParam</a> type.
--   
--   The instances for <a>String</a>, strict <a>Text</a>, and lazy
--   <a>Text</a> are all encoded using UTF-8 before being URL-encoded.
--   
--   The instance for <a>Maybe</a> gives an empty string on <a>Nothing</a>,
--   and otherwise uses the contained type's instance.
class FormValue a

-- | A single part of a multipart message.
data Part :: *

-- | A lens onto the name of the <tt><a>input</a></tt> element associated
--   with part of a multipart form upload.
partName :: Lens' Part Text

-- | A lens onto the filename associated with part of a multipart form
--   upload.
partFileName :: Lens' Part (Maybe String)

-- | A lens onto the content-type associated with part of a multipart form
--   upload.
partContentType :: Traversal' Part (Maybe MimeType)

-- | A lens onto the code that fetches the data associated with part of a
--   multipart form upload.
partGetBody :: Lens' Part (IO RequestBody)

-- | Make a <a>Part</a> whose content is a strict <a>ByteString</a>.
--   
--   The <a>Part</a> does not have a file name or content type associated
--   with it.
partBS :: Text -> ByteString -> Part

-- | Make a <a>Part</a> whose content is a lazy <a>ByteString</a>.
--   
--   The <a>Part</a> does not have a file name or content type associated
--   with it.
partLBS :: Text -> ByteString -> Part

-- | Make a <tt>Part</tt> whose content is a strict <a>Text</a>, encoded as
--   UTF-8.
--   
--   The <tt>Part</tt> does not have a file name or content type associated
--   with it.
partText :: Text -> Text -> Part

-- | Make a <tt>Part</tt> whose content is a <a>String</a>, encoded as
--   UTF-8.
--   
--   The <tt>Part</tt> does not have a file name or content type associated
--   with it.
partString :: Text -> String -> Part

-- | Make a <a>Part</a> from a file.
--   
--   The entire file will reside in memory at once. If you want constant
--   memory usage, use <a>partFileSource</a>.
--   
--   The <a>FilePath</a> supplied will be used as the file name of the
--   <a>Part</a>. If you do not want to reveal this name to the server, you
--   must remove it prior to uploading.
--   
--   The <a>Part</a> does not have a content type associated with it.
partFile :: Text -> FilePath -> Part

-- | Stream a <a>Part</a> from a file.
--   
--   The <a>FilePath</a> supplied will be used as the file name of the
--   <a>Part</a>. If you do not want to reveal this name to the server, you
--   must remove it prior to uploading.
--   
--   The <a>Part</a> does not have a content type associated with it.
partFileSource :: Text -> FilePath -> Part

-- | A simple representation of the HTTP response.
--   
--   Since 0.1.0
data Response body :: * -> *

-- | A lens onto the body of a response.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^.</a> <a>responseBody</a>)
--    
--   </pre>
responseBody :: Lens (Response body0) (Response body1) body0 body1

-- | A lens onto all matching named headers in an HTTP response.
--   
--   To access exactly one header (the result will be the empty string if
--   there is no match), use the (<a>^.</a>) operator.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^.</a> <a>responseHeader</a> "Content-Type")
--    
--   </pre>
--   
--   To access at most one header (the result will be <a>Nothing</a> if
--   there is no match), use the (<a>^?</a>) operator.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^?</a> <a>responseHeader</a> "Content-Transfer-Encoding")
--    
--   </pre>
--   
--   To access all (zero or more) matching headers, use the (<a>^..</a>)
--   operator.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://httpbin.org/get"
--   print (r <a>^..</a> <a>responseHeader</a> "Set-Cookie")
--    
--   </pre>
responseHeader :: HeaderName -> Traversal' (Response body) ByteString

-- | A fold over <tt>Link</tt> headers, matching on both parameter name and
--   value.
--   
--   For example, here is a <tt>Link</tt> header returned by the GitHub
--   search API.
--   
--   <pre>
--   Link:
--     &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=2&gt;; rel="next",
--     &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=34&gt;; rel="last"
--   </pre>
--   
--   And here is an example of how we can retrieve the URL for the
--   <tt>next</tt> link programatically.
--   
--   <pre>
--   r &lt;- <a>get</a> "https://api.github.com/search/code?q=addClass+user:mozilla"
--   print (r <a>^?</a> <a>responseLink</a> "rel" "next" . <a>linkURL</a>)
--    
--   </pre>
responseLink :: ByteString -> ByteString -> Fold (Response body) Link

-- | A fold over any cookies that match the given name.
--   
--   <pre>
--   r &lt;- <a>get</a> "http://www.nytimes.com/"
--   print (r <a>^?</a> responseCookie "RMID")
--    
--   </pre>
responseCookie :: ByteString -> Fold (Response body) Cookie

-- | A lens onto all headers in an HTTP response.
responseHeaders :: Lens' (Response body) ResponseHeaders

-- | A lens onto all cookies set in the response.
responseCookieJar :: Lens' (Response body) CookieJar

-- | A lens onto the status of an HTTP response.
responseStatus :: Lens' (Response body) Status

-- | HTTP Status.
--   
--   Only the <a>statusCode</a> is used for comparisons.
--   
--   Please use <a>mkStatus</a> to create status codes from code and
--   message, or the <a>Enum</a> instance or the status code constants
--   (like <a>ok200</a>). There might be additional record members in the
--   future.
--   
--   Note that the Show instance is only for debugging.
data Status :: *

-- | A lens onto the numeric identifier of an HTTP status.
statusCode :: Lens' Status Int

-- | A lens onto the textual description of an HTTP status.
statusMessage :: Lens' Status ByteString

-- | An element of a <tt>Link</tt> header.
data Link

-- | A lens onto the URL portion of a <tt>Link</tt> element.
linkURL :: Lens' Link ByteString

-- | A lens onto the parameters of a <tt>Link</tt> element.
linkParams :: Lens' Link [(ByteString, ByteString)]

-- | The error type used by <a>asJSON</a> and <a>asValue</a> if a failure
--   occurs when parsing a response body as JSON.
data JSONError
JSONError :: String -> JSONError

-- | Convert the body of an HTTP response from JSON to a suitable Haskell
--   type.
--   
--   In this example, we use <a>asJSON</a> in the <tt>IO</tt> monad, where
--   it will throw a <a>JSONError</a> exception if conversion to the
--   desired type fails.
--   
--   <pre>
--    {-# LANGUAGE DeriveGeneric #-}
--   import <a>GHC.Generics</a> (<a>Generic</a>)
--   
--    {- This Haskell type corresponds to the structure of a
--      response body from httpbin.org. -}
--   
--   data GetBody = GetBody {
--       headers :: <a>Map</a> <a>Text</a> <a>Text</a>
--     , args :: <a>Map</a> <a>Text</a> <a>Text</a>
--     , origin :: <a>Text</a>
--     , url :: <a>Text</a>
--     } deriving (Show, <a>Generic</a>)
--   
--    -- Get GHC to derive a <a>FromJSON</a> instance for us.
--   instance <a>FromJSON</a> GetBody
--   
--    {- The fact that we want a GetBody below will be inferred by our
--      use of the "headers" accessor function. -}
--   
--   foo = do
--     r &lt;- <a>asJSON</a> =&lt;&lt; <a>get</a> "http://httpbin.org/get"
--     print (headers (r <a>^.</a> <tt>responseBody</tt>))
--    
--   </pre>
--   
--   If we use <a>asJSON</a> in the <a>Either</a> monad, it will return
--   <a>Left</a> with a <a>JSONError</a> payload if conversion fails, and
--   <a>Right</a> with a <a>Response</a> whose <tt>responseBody</tt> is the
--   converted value on success.
asJSON :: (MonadThrow m, FromJSON a) => Response ByteString -> m (Response a)

-- | Convert the body of an HTTP response from JSON to a <tt>Value</tt>.
--   
--   In this example, we use <a>asValue</a> in the <tt>IO</tt> monad, where
--   it will throw a <a>JSONError</a> exception if the conversion to
--   <tt>Value</tt> fails.
--   
--   <pre>
--   foo = do
--     r &lt;- <a>asValue</a> =&lt;&lt; <a>get</a> "http://httpbin.org/get"
--     print (r <a>^?</a> <tt>responseBody</tt> . key "headers" . key "User-Agent")
--    
--   </pre>
asValue :: (MonadThrow m) => Response ByteString -> m (Response Value)
data Cookie :: *

-- | A lens onto the name of a cookie.
cookieName :: Lens' Cookie ByteString

-- | A lens onto the value of a cookie.
cookieValue :: Lens' Cookie ByteString

-- | A lens onto the expiry time of a cookie.
cookieExpiryTime :: Lens' Cookie UTCTime

-- | A lens onto the domain of a cookie.
cookieDomain :: Lens' Cookie ByteString

-- | A lens onto the path of a cookie.
cookiePath :: Lens' Cookie ByteString

-- | Turn an attoparsec <a>Parser</a> into a <a>Fold</a>.
--   
--   Both headers and bodies can contain complicated data that we may need
--   to parse.
--   
--   Example: when responding to an OPTIONS request, a server may return
--   the list of verbs it supports in any order, up to and including
--   changing the order on every request (which httpbin.org /actually
--   does/!). To deal with this possibility, we parse the list, then sort
--   it.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Attoparsec.ByteString.Char8 as A
--   
--   &gt;&gt;&gt; import Data.List (sort)
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; let comma = skipSpace &gt;&gt; "," &gt;&gt; skipSpace
--   
--   &gt;&gt;&gt; let verbs = A.takeWhile isAlpha_ascii `sepBy` comma
--   
--   &gt;&gt;&gt; 
--   
--   &gt;&gt;&gt; r &lt;- options "http://httpbin.org/get"
--   
--   &gt;&gt;&gt; r ^. responseHeader "Allow" . atto verbs . to sort
--   ["GET","HEAD","OPTIONS"]
--   </pre>
atto :: Parser a -> Fold ByteString a

-- | The same as <a>atto</a>, but ensures that the parser consumes the
--   entire input.
--   
--   Equivalent to:
--   
--   <pre>
--   <a>atto_</a> myParser = <a>atto</a> (myParser <a>&lt;*</a> <a>endOfInput</a>)
--    
--   </pre>
atto_ :: Parser a -> Fold ByteString a


-- | The functions in this module use a <a>Session</a> to handle the
--   following common needs:
--   
--   <ul>
--   <li>TCP connection reuse. This is important for performance when
--   multiple requests go to a single server, particularly if TLS is being
--   used.</li>
--   <li>Transparent cookie management. Any cookies set by the server
--   persist from one request to the next. (Bypass this overhead using
--   <a>withAPISession</a>.)</li>
--   </ul>
--   
--   This module is designed to be used alongside the <a>Network.Wreq</a>
--   module. Typical usage will look like this:
--   
--   <pre>
--   import <a>Network.Wreq</a>
--   import qualified <a>Network.Wreq.Session</a> as Sess
--   
--   main = Sess.<a>withSession</a> $ \sess -&gt;
--     Sess.<a>get</a> sess "http://httpbin.org/get"
--   </pre>
--   
--   We create a <a>Session</a> using <a>withSession</a>, then pass the
--   session to subsequent functions. When talking to a REST-like service
--   that does not use cookies, it is more efficient to use
--   <a>withAPISession</a>.
--   
--   Note the use of qualified import statements in the examples above, so
--   that we can refer unambiguously to the <a>Session</a>-specific
--   implementation of HTTP GET.
module Network.Wreq.Session

-- | A session that spans multiple requests. This is responsible for cookie
--   management and TCP connection reuse.
data Session

-- | Create a <a>Session</a>, passing it to the given function. The
--   <a>Session</a> will no longer be valid after that function returns.
--   
--   This session manages cookies and uses default session manager
--   configuration.
withSession :: (Session -> IO a) -> IO a

-- | Create a session.
--   
--   This uses the default session manager settings, but does not manage
--   cookies. It is intended for use with REST-like HTTP-based APIs, which
--   typically do not use cookies.
withAPISession :: (Session -> IO a) -> IO a

-- | Create a session, using the given manager settings. This session
--   manages cookies.

-- | <i>Deprecated: Use withSessionControl instead.</i>
withSessionWith :: ManagerSettings -> (Session -> IO a) -> IO a

-- | Create a session, using the given cookie jar and manager settings.
withSessionControl :: Maybe CookieJar -> ManagerSettings -> (Session -> IO a) -> IO a

-- | <a>Session</a>-specific version of <a>get</a>.
get :: Session -> String -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>post</a>.
post :: Postable a => Session -> String -> a -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>head_</a>.
head_ :: Session -> String -> IO (Response ())

-- | <a>Session</a>-specific version of <a>options</a>.
options :: Session -> String -> IO (Response ())

-- | <a>Session</a>-specific version of <a>put</a>.
put :: Putable a => Session -> String -> a -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>delete</a>.
delete :: Session -> String -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>getWith</a>.
getWith :: Options -> Session -> String -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>postWith</a>.
postWith :: Postable a => Options -> Session -> String -> a -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>headWith</a>.
headWith :: Options -> Session -> String -> IO (Response ())

-- | <a>Session</a>-specific version of <a>optionsWith</a>.
optionsWith :: Options -> Session -> String -> IO (Response ())

-- | <a>Session</a>-specific version of <a>putWith</a>.
putWith :: Putable a => Options -> Session -> String -> a -> IO (Response ByteString)

-- | <a>Session</a>-specific version of <a>deleteWith</a>.
deleteWith :: Options -> Session -> String -> IO (Response ByteString)
seshRun :: Lens' Session (Session -> Run Body -> Run Body)
